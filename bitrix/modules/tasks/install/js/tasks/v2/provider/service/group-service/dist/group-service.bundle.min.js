this.BX=this.BX||{};this.BX.Tasks=this.BX.Tasks||{};this.BX.Tasks.V2=this.BX.Tasks.V2||{};this.BX.Tasks.V2.Provider=this.BX.Tasks.V2.Provider||{};(function(e,r,t,s){"use strict";function o(e){return{id:e.id,name:e.name,image:e.image,type:e.type}}function a(e){var r,t;return{id:e.id,name:e.name,image:(r=e.image)==null?void 0:r.src,type:e.type,stagesIds:(t=e.stages)==null?void 0:t.map((({id:e})=>e))}}function i(e){return{id:e.id,title:e.title,color:e.color}}var l=babelHelpers.classPrivateFieldLooseKey("scrumInfoCache");var n=babelHelpers.classPrivateFieldLooseKey("groupInfoPromises");class c{constructor(){Object.defineProperty(this,l,{writable:true,value:{0:true}});Object.defineProperty(this,n,{writable:true,value:{}})}async getUrl(e,t){if(t!==r.GroupType.Collab){return`/workgroups/group/${e}/`}try{return s.apiClient.post("Group.getUrl",{id:e,type:t})}catch(e){console.error("GroupService: getUrl error",e);return""}}async getStages(e){try{const o=await s.apiClient.post("Group.Stage.list",{group:{id:e}});const a=o.map((e=>i(e)));const l=a.map((e=>e.id));await Promise.all([t.Core.getStore().dispatch(`${r.Model.Stages}/upsertMany`,a),t.Core.getStore().dispatch(`${r.Model.Groups}/update`,{id:e,fields:{stagesIds:l}})])}catch(e){console.error("GroupService: getStages error",e)}}async getGroup(e){try{const o=await s.apiClient.post("Group.get",{group:{id:e}});const i=a(o);await t.Core.getStore().dispatch(`${r.Model.Groups}/insert`,i);return i}catch(e){console.error("GroupService: getGroup error",e);return null}}async getScrumInfo(e){if(this.hasScrumInfo(e)){return}babelHelpers.classPrivateFieldLooseBase(this,l)[l][e]=true;try{var o;const a=await s.apiClient.post("Scrum.getTaskInfo",{taskId:e});await Promise.all([t.Core.getStore().dispatch(`${r.Model.Epics}/upsert`,a.epic),t.Core.getStore().dispatch(`${r.Model.Tasks}/update`,{id:e,fields:{storyPoints:a.storyPoints,epicId:(o=a.epic)==null?void 0:o.id}})])}catch(e){console.error("GroupService: getScrumInfo error",e)}}hasScrumInfo(e){return babelHelpers.classPrivateFieldLooseBase(this,l)[l][e]}async getGroupInfo(e){if(babelHelpers.classPrivateFieldLooseBase(this,n)[n][e]){return babelHelpers.classPrivateFieldLooseBase(this,n)[n][e]}babelHelpers.classPrivateFieldLooseBase(this,n)[n][e]=new p;try{var r,t,s;const o=Object.freeze({OwnerData:"OWNER_DATA",DateCreate:"DATE_CREATE",SubjectData:"SUBJECT_DATA",NumberOfMembers:"NUMBER_OF_MEMBERS"});const{data:a}=await BX.ajax.runAction("socialnetwork.api.workgroup.get",{data:{params:{select:Object.values(o),groupId:e}}});babelHelpers.classPrivateFieldLooseBase(this,n)[n][e].resolve({ownerId:(r=a[o.OwnerData])==null?void 0:r.ID,ownerName:(t=a[o.OwnerData])==null?void 0:t.FORMATTED_NAME,dateCreate:a[o.DateCreate],subjectTitle:(s=a[o.SubjectData])==null?void 0:s.NAME,numberOfMembers:a[o.NumberOfMembers]});return babelHelpers.classPrivateFieldLooseBase(this,n)[n][e]}catch(e){console.error("GroupService: getGroupInfo error",e);return{}}}}const u=new c;function p(){const e=new Promise((e=>{this.resolve=e}));e.resolve=this.resolve;return e}const d={mapModelToDto:o,mapDtoToModel:a,mapStageDtoToModel:i};e.GroupMappers=d;e.groupService=u})(this.BX.Tasks.V2.Provider.Service=this.BX.Tasks.V2.Provider.Service||{},BX.Tasks.V2.Const,BX.Tasks.V2,BX.Tasks.V2.Lib);
//# sourceMappingURL=group-service.bundle.map.js